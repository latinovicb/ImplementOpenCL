From 838e3252801e5a5e4572d02239e161c69a62d121 Mon Sep 17 00:00:00 2001
From: BL <borek.latinovic@powerdynax.com>
Date: Tue, 21 Nov 2023 00:58:18 +0200
Subject: [PATCH 04/16] First implementation

Add the OpenCL init API calls taken from the the rotation file and
vectoradd
Initialize in init function and destroy in destroy function
Create global variables easy access
All functions in cl file generated by ChatGPT.
Create own makefile

NOTE:
Still not functional
---
 Makefile |   6 ++
 canny.c  | 248 ++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 canny.cl | 131 +++++++++++++++++++++++++++++
 3 files changed, 382 insertions(+), 3 deletions(-)
 create mode 100644 Makefile

diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..c1c98bd
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,6 @@
+CC = gcc
+OPENCL_INCLUDE_PATH = /opt/AMDAPP/include
+OPENCL_LIB_PATH = /opt/AMDAPP/lib/x86_64
+
+canny: canny.c
+	$(CC) -o canny canny.c -I${OPENCL_INCLUDE_PATH} -L${OPENCL_LIB_PATH} -lOpenCL
diff --git a/canny.c b/canny.c
index a1f2845..992e844 100644
--- a/canny.c
+++ b/canny.c
@@ -13,6 +13,7 @@ VERSION 23.0 - Created
 #include <string.h>
 #include <omp.h>
 
+#include <CL/cl.h>
 #include "util.h"
 
 // Is used to find out frame times
@@ -20,6 +21,41 @@ int previousFinishTime = 0;
 unsigned int frameNumber = 0;
 unsigned int seed = 0;
 
+//*************************GLOBALS**********************************
+
+// for checking status
+cl_int status;
+
+// device ids
+
+cl_uint numPlatforms = 0;
+cl_platform_id *platforms = NULL;
+cl_uint numDevices = 0;
+cl_device_id *devices;
+
+// context
+cl_context context;
+
+// command queue
+cl_command_queue queue;
+
+//buffers
+cl_mem buffer_input_image;
+cl_mem buffer_output_image;
+cl_mem sobel_x_input;
+cl_mem sobel_y_input;
+cl_mem phase_input;
+cl_mem magnitude_input;
+
+
+// kernels
+cl_program program;
+cl_kernel kernel_sobel;
+cl_kernel kernel_phase_mag;
+cl_kernel kernel_kernel_max_supp;
+
+//**********************************************************************
+//
 typedef struct {
     uint16_t x;
     uint16_t y;
@@ -261,11 +297,64 @@ edgeTracing(uint8_t *restrict image, size_t width, size_t height) {
     }
 }
 
+void chk(cl_int status, const char* cmd) {
+
+   if(status != CL_SUCCESS) {
+      printf("%s failed (%d)\n", cmd, status);
+      exit(-1);
+   }
+}
+
+char* readSource(char* kernelPath) {
+
+   FILE *fp;
+   char *source;
+   long int size;
+
+   printf("Program file is: %s\n", kernelPath);
+
+   fp = fopen(kernelPath, "rb");
+   if(!fp) {
+      printf("Could not open kernel file\n");
+      exit(-1);
+   }
+   status = fseek(fp, 0, SEEK_END);
+   if(status != 0) {
+      printf("Error seeking to end of file\n");
+      exit(-1);
+   }
+   size = ftell(fp);
+   if(size < 0) {
+      printf("Error getting file position\n");
+      exit(-1);
+   }
+
+   rewind(fp);
+
+   source = (char *)malloc(size + 1);
+
+   int i;
+   for (i = 0; i < size+1; i++) {
+      source[i]='\0';
+   }
+
+   if(source == NULL) {
+      printf("Error allocating space for the kernel source\n");
+      exit(-1);
+   }
+
+   fread(source, 1, size, fp);
+   source[size] = '\0';
+
+   return source;
+}
+
 void
 cannyEdgeDetection(
     uint8_t *restrict input, size_t width, size_t height,
     uint16_t threshold_lower, uint16_t threshold_upper,
     uint8_t *restrict output, double *restrict runtimes) {
+
     size_t image_size = width * height;
 
     // Allocate arrays for intermediate results
@@ -284,7 +373,76 @@ cannyEdgeDetection(
     uint64_t times[5];
     // Canny edge detection algorithm consists of the following functions:
     times[0] = gettimemono_ns();
-    sobel3x3(input, width, height, sobel_x, sobel_y);
+   
+
+   // *************************************************************
+   // Set up the OpenCL environment
+   // Read source file
+   const char* source = readSource("rotation.cl");
+  
+    // Write input images to buffers
+
+   status = clEnqueueWriteBuffer(queue, buffer_input_image, CL_TRUE, 0, sizeof(uint8_t) * width * height, 
+         input, 0, NULL, NULL);
+   chk(status, "clEnqueueWriteBuffer");
+
+   // Write variables to buffers
+   status = clEnqueueWriteBuffer(queue, sobel_x_input, CL_TRUE, 0, sizeof(int16_t) * width * height, 
+         sobel_x, 0, NULL, NULL);
+   chk(status, "clEnqueueWriteBuffer");
+
+   status = clEnqueueWriteBuffer(queue, sobel_y_input, CL_TRUE, 0, sizeof(int16_t) * width * height, 
+         sobel_y, 0, NULL, NULL);
+   chk(status, "clEnqueueWriteBuffer");
+
+   status = clEnqueueWriteBuffer(queue, phase_input, CL_TRUE, 0, sizeof(uint8_t) * width * height, 
+         phase, 0, NULL, NULL);
+   chk(status, "clEnqueueWriteBuffer");
+
+   status = clEnqueueWriteBuffer(queue, magnitude_input, CL_TRUE, 0, sizeof(uint8_t) * width * height, 
+         magnitude, 0, NULL, NULL);
+   chk(status, "clEnqueueWriteBuffer");
+
+    // Create program object with source
+   program = clCreateProgramWithSource(context, 1, &source, NULL, NULL);
+   chk(status, "clCreateProgramWithSource");
+   status = clBuildProgram(program, 1, devices, NULL, NULL, NULL);
+   chk(status, "clBuildProgram");
+
+   // Create the kernel object
+
+   kernel_sobel = clCreateKernel(program, "sobel3x3", &status);
+   // kernel_phase_mag = clCreateKernel(program, "phaseAndMagnitude", &status);
+   // kernel_kernel_max_supp = clCreateKernel(program, "nonMaxSuppression", &status);
+   chk(status, "clCreateKernel");
+    
+   
+    status = clSetKernelArg(kernel_sobel, 0, sizeof(uint8_t) * width * height, &input);
+    status |= clSetKernelArg(kernel_sobel, 1, sizeof(size_t), &width);
+    status |= clSetKernelArg(kernel_sobel, 2, sizeof(size_t), &height);
+    status |= clSetKernelArg(kernel_sobel, 3, sizeof(cl_mem), &sobel_x);
+    status |= clSetKernelArg(kernel_sobel, 4, sizeof(cl_mem), &sobel_y);
+    chk(status, "clSetKernelArg");
+  
+
+   size_t globalSize[2] = {width, height};
+
+   status = clEnqueueNDRangeKernel(queue, kernel_sobel, 2, NULL, globalSize, NULL, 0,
+      NULL, NULL);
+
+   chk(status, "clEnqueueNDRange");
+
+   status = clEnqueueReadBuffer(queue, sobel_x_input, CL_TRUE, 0, sizeof(uint8_t) * width * height, 
+         sobel_x, 0, NULL, NULL); 
+   chk(status, "clEnqueueReadBuffer");
+
+   status = clEnqueueReadBuffer(queue, sobel_y_input, CL_TRUE, 0, sizeof(uint8_t) * width * height, 
+         sobel_y, 0, NULL, NULL); 
+   chk(status, "clEnqueueReadBuffer");
+
+   // CONTINUE HERE from rotator project
+
+    // sobel3x3(input, width, height, sobel_x, sobel_y);
 
     times[1] = gettimemono_ns();
     phaseAndMagnitude(sobel_x, sobel_y, width, height, phase, magnitude);
@@ -314,10 +472,94 @@ cannyEdgeDetection(
 void
 init(
     size_t width, size_t height, uint16_t threshold_lower,
-    uint16_t threshold_upper) {}
+    uint16_t threshold_upper) {
+
+    // device ID stuff here
+
+    // Retrieve the number of platforms
+    status = clGetPlatformIDs(0, NULL, &numPlatforms);
+ 
+    // Allocate enough space for each platform
+    platforms = (cl_platform_id*)malloc(
+        numPlatforms*sizeof(cl_platform_id));
+ 
+    // Fill in the platforms
+    status = clGetPlatformIDs(numPlatforms, platforms, NULL);
+
+    // Retrieve the number of devices
+    status = clGetDeviceIDs(platforms[0], CL_DEVICE_TYPE_ALL, 0, 
+        NULL, &numDevices);
+    chk(status,"clGetDeviceIDs");
+
+    // Allocate enough space for each device
+    devices = (cl_device_id*)malloc(
+        numDevices*sizeof(cl_device_id));
+
+    // Fill in the devices 
+    status = clGetDeviceIDs(platforms[0], CL_DEVICE_TYPE_ALL,        
+        numDevices, devices, NULL);
+    chk(status,"clGetDeviceIDs");
+
+   // Create context
+   context = clCreateContext(NULL, numDevices, devices, NULL, NULL, &status);
+   chk(status, "clCreateContext");
+
+   // -------------------------------------------------
+   // Create command queue
+   queue = clCreateCommandQueue(context, devices[0], CL_QUEUE_PROFILING_ENABLE, &status);
+   chk(status, "clCreateCommandQueue");
+
+   // Create the input and output buffer for images
+   buffer_input_image = clCreateBuffer(context, CL_MEM_READ_ONLY, sizeof(uint8_t)*width*height, NULL,
+       &status);
+   chk(status, "clCreateBuffer");
+
+   buffer_output_image = clCreateBuffer(context, CL_MEM_READ_ONLY, sizeof(uint8_t)*width*height, NULL,
+       &status);
+   chk(status, "clCreateBuffer");
+
+   // Create the input and output buffers
+   sobel_x_input = clCreateBuffer(context, CL_MEM_WRITE_ONLY, sizeof(uint16_t)*width*height, NULL,
+       &status);
+   chk(status, "clCreateBuffer");
+
+   sobel_y_input = clCreateBuffer(context, CL_MEM_READ_WRITE, sizeof(uint16_t)*width*height, NULL,
+       &status);
+   chk(status, "clCreateBuffer");
+
+   phase_input = clCreateBuffer(context, CL_MEM_READ_WRITE, sizeof(uint16_t)*width*height, NULL,
+       &status);
+   chk(status, "clCreateBuffer");
+
+   magnitude_input = clCreateBuffer(context, CL_MEM_READ_WRITE, sizeof(uint16_t)*width*height , NULL,
+       &status);
+   chk(status, "clCreateBuffer");
+
+
+}
 
 void
-destroy() {}
+destroy() {
+  
+    // sobel stuff
+    clReleaseKernel(kernel_sobel);
+    clReleaseProgram(program);
+    clReleaseCommandQueue(queue);
+
+    clReleaseMemObject(buffer_input_image);
+    clReleaseMemObject(buffer_output_image);
+    clReleaseMemObject(sobel_x_input);
+    clReleaseMemObject(sobel_y_input);
+    clReleaseMemObject(phase_input);
+    clReleaseMemObject(magnitude_input);
+
+    // release rest of the stuff as well
+    // clReleaseMemObject(bufA);
+    // clReleaseMemObject(bufB);
+    // clReleaseMemObject(bufC);
+    // clReleaseContext(context);
+
+}
 
 ////////////////////////////////////////////////
 // 造造 DO NOT EDIT ANYTHING AFTER THIS LINE 造造 //
diff --git a/canny.cl b/canny.cl
index 8b13789..2b3ba3d 100644
--- a/canny.cl
+++ b/canny.cl
@@ -1 +1,132 @@
+#define WIDTH   // Define the width of your image
+#define HEIGHT  // Define the height of your image
+
+__kernel void sobel3x3(__global const uchar *in,
+                       __global short *output_x,
+                       __global short *output_y) {
+    size_t gid_x = get_global_id(0);  // Equivalent to 'x' in the original code
+    size_t gid_y = get_global_id(1);  // Equivalent to 'y' in the original code
+
+    if (gid_x < WIDTH && gid_y < HEIGHT) {
+        size_t gid = gid_y * WIDTH + gid_x;
+
+        /* 3x3 sobel filter, first in x direction */
+        output_x[gid] = (-1) * in[idx(gid_x, gid_y, WIDTH, HEIGHT, -1, -1)] +
+                        1 * in[idx(gid_x, gid_y, WIDTH, HEIGHT, 1, -1)] +
+                        (-2) * in[idx(gid_x, gid_y, WIDTH, HEIGHT, -1, 0)] +
+                        2 * in[idx(gid_x, gid_y, WIDTH, HEIGHT, 1, 0)] +
+                        (-1) * in[idx(gid_x, gid_y, WIDTH, HEIGHT, -1, 1)] +
+                        1 * in[idx(gid_x, gid_y, WIDTH, HEIGHT, 1, 1)];
+
+        /* 3x3 sobel filter, in y direction */
+        output_y[gid] = (-1) * in[idx(gid_x, gid_y, WIDTH, HEIGHT, -1, -1)] +
+                        1 * in[idx(gid_x, gid_y, WIDTH, HEIGHT, -1, 1)] +
+                        (-2) * in[idx(gid_x, gid_y, WIDTH, HEIGHT, 0, -1)] +
+                        2 * in[idx(gid_x, gid_y, WIDTH, HEIGHT, 0, 1)] +
+                        (-1) * in[idx(gid_x, gid_y, WIDTH, HEIGHT, 1, -1)] +
+                        1 * in[idx(gid_x, gid_y, WIDTH, HEIGHT, 1, 1)];
+    }
+}
+
+#define PI 3.14159265358979323846
+
+__kernel void phaseAndMagnitude(
+    __global const short *restrict in_x, __global const short *restrict in_y,
+    const unsigned int width, const unsigned int height,
+    __global uchar *restrict phase_out,
+    __global ushort *restrict magnitude_out) {
+
+    size_t gid_x = get_global_id(0);
+    size_t gid_y = get_global_id(1);
+
+    if (gid_x < width && gid_y < height) {
+        size_t gid = gid_y * width + gid_x;
+
+        // Output in range -PI:PI
+        float angle = atan2(in_y[gid], in_x[gid]);
+
+        // Shift range -1:1
+        angle /= PI;
+
+        // Shift range -127.5:127.5
+        angle *= 127.5;
+
+        // Shift range 0.5:255.5
+        angle += (127.5 + 0.5);
+
+        // Downcasting truncates angle to range 0:255
+        phase_out[gid] = convert_uchar_sat(angle);
+
+        magnitude_out[gid] = abs(in_x[gid]) + abs(in_y[gid]);
+    }
+}
+
+__kernel void nonMaxSuppression(
+    __global const ushort *magnitude, __global const uchar *phase,
+    size_t width, size_t height, short threshold_lower,
+    ushort threshold_upper, __global uchar *out) {
+    
+    size_t gid_x = get_global_id(0);
+    size_t gid_y = get_global_id(1);
+    size_t gid = gid_y * width + gid_x;
+
+    uchar sobel_angle = phase[gid];
+
+    if (sobel_angle > 127) {
+        sobel_angle -= 128;
+    }
+
+    int sobel_orientation = 0;
+
+    if (sobel_angle < 16 || sobel_angle >= (7 * 16)) {
+        sobel_orientation = 2;
+    } else if (sobel_angle >= 16 && sobel_angle < 16 * 3) {
+        sobel_orientation = 1;
+    } else if (sobel_angle >= 16 * 3 && sobel_angle < 16 * 5) {
+        sobel_orientation = 0;
+    } else if (sobel_angle > 16 * 5 && sobel_angle <= 16 * 7) {
+        sobel_orientation = 3;
+    }
+
+    ushort sobel_magnitude = magnitude[gid];
+    /* Non-maximum suppression
+     * Pick out the two neighbors that are perpendicular to the
+     * current edge pixel */
+    ushort neighbour_max = 0;
+    ushort neighbour_max2 = 0;
+
+    switch (sobel_orientation) {
+        case 0:
+            neighbour_max = magnitude[gid - width];
+            neighbour_max2 = magnitude[gid + width];
+            break;
+        case 1:
+            neighbour_max = magnitude[gid - width - 1];
+            neighbour_max2 = magnitude[gid + width + 1];
+            break;
+        case 2:
+            neighbour_max = magnitude[gid - 1];
+            neighbour_max2 = magnitude[gid + 1];
+            break;
+        case 3:
+        default:
+            neighbour_max = magnitude[gid + width - 1];
+            neighbour_max2 = magnitude[gid - width + 1];
+            break;
+    }
+
+    // Suppress the pixel here
+    if ((sobel_magnitude < neighbour_max) ||
+        (sobel_magnitude < neighbour_max2)) {
+        sobel_magnitude = 0;
+    }
+
+    /* Double thresholding */
+    // Marks YES pixels with 255, NO pixels with 0, and MAYBE pixels
+    // with 127
+    uchar t = 127;
+    if (sobel_magnitude > threshold_upper) t = 255;
+    if (sobel_magnitude <= threshold_lower) t = 0;
+    out[gid] = t;
+}
 
-- 
2.34.1

